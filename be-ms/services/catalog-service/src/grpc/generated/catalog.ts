// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: catalog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "catalog";

export interface SearchRequest {
  search: string;
}

export interface GetProductsRequest {
  page: number;
  limit: number;
  category: string;
  sort: string;
}

export interface GetCategoriesRequest {
}

export interface CategoryResponse {
  id: string;
  category: string;
}

export interface ProductResponse {
  id: string;
  productId: string;
  name: string;
  title: string;
  price: number;
  quantity: number;
  category: string;
  imageUrl: string;
  inStock: boolean;
}

export interface ErrorDetail {
  field: string;
  message: string;
}

export interface ErrorsList {
  errors: ErrorDetail[];
}

export interface ProductListResponse {
  products: ProductResponse[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface CategoryListResponse {
  categories: string[];
}

function createBaseSearchRequest(): SearchRequest {
  return { search: "" };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return { search: isSet(object.search) ? globalThis.String(object.search) : "" };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.search !== "") {
      obj.search = message.search;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.search = object.search ?? "";
    return message;
  },
};

function createBaseGetProductsRequest(): GetProductsRequest {
  return { page: 0, limit: 0, category: "", sort: "" };
}

export const GetProductsRequest: MessageFns<GetProductsRequest> = {
  encode(message: GetProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.sort !== "") {
      writer.uint32(34).string(message.sort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sort = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
    };
  },

  toJSON(message: GetProductsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductsRequest>, I>>(base?: I): GetProductsRequest {
    return GetProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductsRequest>, I>>(object: I): GetProductsRequest {
    const message = createBaseGetProductsRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.category = object.category ?? "";
    message.sort = object.sort ?? "";
    return message;
  },
};

function createBaseGetCategoriesRequest(): GetCategoriesRequest {
  return {};
}

export const GetCategoriesRequest: MessageFns<GetCategoriesRequest> = {
  encode(_: GetCategoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCategoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCategoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetCategoriesRequest {
    return {};
  },

  toJSON(_: GetCategoriesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCategoriesRequest>, I>>(base?: I): GetCategoriesRequest {
    return GetCategoriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCategoriesRequest>, I>>(_: I): GetCategoriesRequest {
    const message = createBaseGetCategoriesRequest();
    return message;
  },
};

function createBaseCategoryResponse(): CategoryResponse {
  return { id: "", category: "" };
}

export const CategoryResponse: MessageFns<CategoryResponse> = {
  encode(message: CategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
    };
  },

  toJSON(message: CategoryResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryResponse>, I>>(base?: I): CategoryResponse {
    return CategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryResponse>, I>>(object: I): CategoryResponse {
    const message = createBaseCategoryResponse();
    message.id = object.id ?? "";
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseProductResponse(): ProductResponse {
  return {
    id: "",
    productId: "",
    name: "",
    title: "",
    price: 0,
    quantity: 0,
    category: "",
    imageUrl: "",
    inStock: false,
  };
}

export const ProductResponse: MessageFns<ProductResponse> = {
  encode(message: ProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    if (message.quantity !== 0) {
      writer.uint32(48).int32(message.quantity);
    }
    if (message.category !== "") {
      writer.uint32(58).string(message.category);
    }
    if (message.imageUrl !== "") {
      writer.uint32(66).string(message.imageUrl);
    }
    if (message.inStock !== false) {
      writer.uint32(72).bool(message.inStock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.inStock = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      inStock: isSet(object.inStock) ? globalThis.Boolean(object.inStock) : false,
    };
  },

  toJSON(message: ProductResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.inStock !== false) {
      obj.inStock = message.inStock;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductResponse>, I>>(base?: I): ProductResponse {
    return ProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductResponse>, I>>(object: I): ProductResponse {
    const message = createBaseProductResponse();
    message.id = object.id ?? "";
    message.productId = object.productId ?? "";
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.price = object.price ?? 0;
    message.quantity = object.quantity ?? 0;
    message.category = object.category ?? "";
    message.imageUrl = object.imageUrl ?? "";
    message.inStock = object.inStock ?? false;
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: "", message: "" };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseErrorsList(): ErrorsList {
  return { errors: [] };
}

export const ErrorsList: MessageFns<ErrorsList> = {
  encode(message: ErrorsList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      ErrorDetail.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorsList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorsList {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ErrorDetail.fromJSON(e)) : [],
    };
  },

  toJSON(message: ErrorsList): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorsList>, I>>(base?: I): ErrorsList {
    return ErrorsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorsList>, I>>(object: I): ErrorsList {
    const message = createBaseErrorsList();
    message.errors = object.errors?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProductListResponse(): ProductListResponse {
  return { products: [], total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const ProductListResponse: MessageFns<ProductListResponse> = {
  encode(message: ProductListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductListResponse {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => ProductResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ProductListResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => ProductResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductListResponse>, I>>(base?: I): ProductListResponse {
    return ProductListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductListResponse>, I>>(object: I): ProductListResponse {
    const message = createBaseProductListResponse();
    message.products = object.products?.map((e) => ProductResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseCategoryListResponse(): CategoryListResponse {
  return { categories: [] };
}

export const CategoryListResponse: MessageFns<CategoryListResponse> = {
  encode(message: CategoryListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryListResponse {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CategoryListResponse): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryListResponse>, I>>(base?: I): CategoryListResponse {
    return CategoryListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryListResponse>, I>>(object: I): CategoryListResponse {
    const message = createBaseCategoryListResponse();
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

export type CatalogServiceService = typeof CatalogServiceService;
export const CatalogServiceService = {
  searchProducts: {
    path: "/catalog.CatalogService/SearchProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchRequest): Buffer => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchRequest => SearchRequest.decode(value),
    responseSerialize: (value: ProductListResponse): Buffer => Buffer.from(ProductListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProductListResponse => ProductListResponse.decode(value),
  },
  getProducts: {
    path: "/catalog.CatalogService/GetProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductsRequest): Buffer => Buffer.from(GetProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProductsRequest => GetProductsRequest.decode(value),
    responseSerialize: (value: ProductListResponse): Buffer => Buffer.from(ProductListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProductListResponse => ProductListResponse.decode(value),
  },
  getCategories: {
    path: "/catalog.CatalogService/GetCategories",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCategoriesRequest): Buffer => Buffer.from(GetCategoriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCategoriesRequest => GetCategoriesRequest.decode(value),
    responseSerialize: (value: CategoryListResponse): Buffer =>
      Buffer.from(CategoryListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CategoryListResponse => CategoryListResponse.decode(value),
  },
} as const;

export interface CatalogServiceServer extends UntypedServiceImplementation {
  searchProducts: handleUnaryCall<SearchRequest, ProductListResponse>;
  getProducts: handleUnaryCall<GetProductsRequest, ProductListResponse>;
  getCategories: handleUnaryCall<GetCategoriesRequest, CategoryListResponse>;
}

export interface CatalogServiceClient extends Client {
  searchProducts(
    request: SearchRequest,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  searchProducts(
    request: SearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  searchProducts(
    request: SearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  getProducts(
    request: GetProductsRequest,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  getProducts(
    request: GetProductsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  getProducts(
    request: GetProductsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProductListResponse) => void,
  ): ClientUnaryCall;
  getCategories(
    request: GetCategoriesRequest,
    callback: (error: ServiceError | null, response: CategoryListResponse) => void,
  ): ClientUnaryCall;
  getCategories(
    request: GetCategoriesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CategoryListResponse) => void,
  ): ClientUnaryCall;
  getCategories(
    request: GetCategoriesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CategoryListResponse) => void,
  ): ClientUnaryCall;
}

export const CatalogServiceClient = makeGenericClientConstructor(
  CatalogServiceService,
  "catalog.CatalogService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CatalogServiceClient;
  service: typeof CatalogServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
